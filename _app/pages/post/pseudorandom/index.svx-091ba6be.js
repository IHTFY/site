import{S as Cr,i as kr,s as Sr,C as Ba,w as xr,x as Yr,y as $r,z as qr,A as wr,q as Or,o as Br,B as Vr,T as Rr,e as o,t as a,k as s,c as n,a as l,h as r,d as e,m as i,b as Ir,g as P,J as t}from"../../../chunks/vendor-4e826582.js";import{P as jr}from"../../../chunks/post-3ebb664d.js";import"../../../chunks/stores-e638db0f.js";import"../../../chunks/Progress-16f77af8.js";/* empty css                                      */function Hr(z){let d,E,v,S,f,m,J,Zt,at,te,ee,rt,ae,re,ot,oe,ne,Vt,p,le,nt,de,se,lt,ie,ce,dt,he,ue,jt,C,st,y,it,fe,_e,ct,ve,me,ht,pe,Ee,u,T,ut,ye,Te,x,ge,ft,De,Ae,Ue,_t,be,we,g,vt,Re,Ie,Y,Pe,mt,Ce,ke,Se,pt,xe,Ye,D,Et,$e,qe,$,Oe,yt,Be,Ve,je,Tt,He,ze,A,gt,Je,Ne,q,Me,Dt,Le,Fe,Ge,At,Ke,Qe,U,Ut,We,Xe,O,Ze,bt,ta,ea,aa,wt,ra,oa,b,Rt,na,la,B,da,It,sa,ia,ca,Pt,ha,ua,w,Ct,fa,_a,V,va,kt,ma,pa,Ea,St,ya,Ta,R,xt,ga,Da,j,Aa,Yt,Ua,ba,wa,$t,Ra,Ia,I,qt,Pa,Ca,H,ka,Ot,Sa,xa,Ya,Bt,$a,Ht,N,qa,zt,M,Oa;return{c(){d=o("p"),E=a("I\u2019m still tinkering around with the "),v=o("a"),S=a("calendar maker"),f=a(". I decided to give each event (birthday, holiday, anniversary, etc.) a random id. Rather than just use "),m=o("code"),J=a("Math.random()"),Zt=a(", I decided to try using the browser\u2019s "),at=o("code"),te=a("Crypto"),ee=a(" interface. There\u2019s a nice function that generates a UUID (universally unique identifier): "),rt=o("code"),ae=a("window.crypto.randomUUID()"),re=a(". The result looks something like this: "),ot=o("code"),oe=a("'a1d803ce-822e-4d2d-a68f-16f85a5c1508'"),ne=a(". This is a 128 bit label which means there are 2128 unique values - around 3.4x1038 or roughly a trillion times a trillion times a trillion."),Vt=s(),p=o("p"),le=a("You can also generate random integers using "),nt=o("code"),de=a("getRandomValues"),se=a(", and following the format (replacing "),lt=o("code"),ie=a("ARRAY"),ce=a("): "),dt=o("code"),he=a("crypto.getRandomValues(new ARRAY(1))[0]"),ue=a(". You can use any of the typed integer arrays in JavaScript."),jt=s(),C=o("table"),st=o("thead"),y=o("tr"),it=o("th"),fe=a("Array"),_e=s(),ct=o("th"),ve=a("Number of Values"),me=s(),ht=o("th"),pe=a("Range"),Ee=s(),u=o("tbody"),T=o("tr"),ut=o("td"),ye=a("Int8Array"),Te=s(),x=o("td"),ge=a("2"),ft=o("sup"),De=a("8"),Ae=a("= 256"),Ue=s(),_t=o("td"),be=a("[-128, 127]"),we=s(),g=o("tr"),vt=o("td"),Re=a("Int16Array"),Ie=s(),Y=o("td"),Pe=a("2"),mt=o("sup"),Ce=a("16"),ke=a("= 65,536"),Se=s(),pt=o("td"),xe=a("[-32768, 32767]"),Ye=s(),D=o("tr"),Et=o("td"),$e=a("Int32Array"),qe=s(),$=o("td"),Oe=a("2"),yt=o("sup"),Be=a("32"),Ve=a("= 4,294,967,296"),je=s(),Tt=o("td"),He=a("[-2147483648, 2147483647]"),ze=s(),A=o("tr"),gt=o("td"),Je=a("Uint8Array"),Ne=s(),q=o("td"),Me=a("2"),Dt=o("sup"),Le=a("8"),Fe=a("= 256"),Ge=s(),At=o("td"),Ke=a("[0, 255]"),Qe=s(),U=o("tr"),Ut=o("td"),We=a("Uint16Array"),Xe=s(),O=o("td"),Ze=a("2"),bt=o("sup"),ta=a("16"),ea=a("= 65,536"),aa=s(),wt=o("td"),ra=a("[0, 65535]"),oa=s(),b=o("tr"),Rt=o("td"),na=a("Uint32Array"),la=s(),B=o("td"),da=a("2"),It=o("sup"),sa=a("32"),ia=a("= 4,294,967,296"),ca=s(),Pt=o("td"),ha=a("[0, 4294967295]"),ua=s(),w=o("tr"),Ct=o("td"),fa=a("Uint8ClampedArray"),_a=s(),V=o("td"),va=a("2"),kt=o("sup"),ma=a("8"),pa=a("= 256"),Ea=s(),St=o("td"),ya=a("[0, 255]"),Ta=s(),R=o("tr"),xt=o("td"),ga=a("BigInt64Array"),Da=s(),j=o("td"),Aa=a("2"),Yt=o("sup"),Ua=a("64"),ba=a(" = 18,446,744,073,709,551,615"),wa=s(),$t=o("td"),Ra=a("[-9223372036854775808, 9223372036854775807]"),Ia=s(),I=o("tr"),qt=o("td"),Pa=a("BitUint64Array"),Ca=s(),H=o("td"),ka=a("2"),Ot=o("sup"),Sa=a("64"),xa=a(" = 18,446,744,073,709,551,615"),Ya=s(),Bt=o("td"),$a=a("[0, 18446744073709551615]"),Ht=s(),N=o("p"),qa=a("The only difference between Uint8Array and Uint8ClampedArray is that the if you try assign a number outside of the range [0, 255], the clamped array will round you up to 0 or down to 255. The Uint8Array will take loop over, so 256 becomes 0, and -1 becomes 255, etc. I don\u2019t think this has an effect on the random output code above though."),zt=s(),M=o("p"),Oa=a("The \u201CU\u201D in the name stands for \u201Cunsigned\u201D, meaning the numbers are non-negative. The signed versions have are just centered around zero, so there are an equal amount of negative and non-negative outcomes."),this.h()},l(c){d=n(c,"P",{});var h=l(d);E=r(h,"I\u2019m still tinkering around with the "),v=n(h,"A",{href:!0,rel:!0});var Va=l(v);S=r(Va,"calendar maker"),Va.forEach(e),f=r(h,". I decided to give each event (birthday, holiday, anniversary, etc.) a random id. Rather than just use "),m=n(h,"CODE",{});var ja=l(m);J=r(ja,"Math.random()"),ja.forEach(e),Zt=r(h,", I decided to try using the browser\u2019s "),at=n(h,"CODE",{});var Ha=l(at);te=r(Ha,"Crypto"),Ha.forEach(e),ee=r(h," interface. There\u2019s a nice function that generates a UUID (universally unique identifier): "),rt=n(h,"CODE",{});var za=l(rt);ae=r(za,"window.crypto.randomUUID()"),za.forEach(e),re=r(h,". The result looks something like this: "),ot=n(h,"CODE",{});var Ja=l(ot);oe=r(Ja,"'a1d803ce-822e-4d2d-a68f-16f85a5c1508'"),Ja.forEach(e),ne=r(h,". This is a 128 bit label which means there are 2128 unique values - around 3.4x1038 or roughly a trillion times a trillion times a trillion."),h.forEach(e),Vt=i(c),p=n(c,"P",{});var k=l(p);le=r(k,"You can also generate random integers using "),nt=n(k,"CODE",{});var Na=l(nt);de=r(Na,"getRandomValues"),Na.forEach(e),se=r(k,", and following the format (replacing "),lt=n(k,"CODE",{});var Ma=l(lt);ie=r(Ma,"ARRAY"),Ma.forEach(e),ce=r(k,"): "),dt=n(k,"CODE",{});var La=l(dt);he=r(La,"crypto.getRandomValues(new ARRAY(1))[0]"),La.forEach(e),ue=r(k,". You can use any of the typed integer arrays in JavaScript."),k.forEach(e),jt=i(c),C=n(c,"TABLE",{});var Jt=l(C);st=n(Jt,"THEAD",{});var Fa=l(st);y=n(Fa,"TR",{});var L=l(y);it=n(L,"TH",{});var Ga=l(it);fe=r(Ga,"Array"),Ga.forEach(e),_e=i(L),ct=n(L,"TH",{});var Ka=l(ct);ve=r(Ka,"Number of Values"),Ka.forEach(e),me=i(L),ht=n(L,"TH",{});var Qa=l(ht);pe=r(Qa,"Range"),Qa.forEach(e),L.forEach(e),Fa.forEach(e),Ee=i(Jt),u=n(Jt,"TBODY",{});var _=l(u);T=n(_,"TR",{});var F=l(T);ut=n(F,"TD",{});var Wa=l(ut);ye=r(Wa,"Int8Array"),Wa.forEach(e),Te=i(F),x=n(F,"TD",{});var Nt=l(x);ge=r(Nt,"2"),ft=n(Nt,"SUP",{});var Xa=l(ft);De=r(Xa,"8"),Xa.forEach(e),Ae=r(Nt,"= 256"),Nt.forEach(e),Ue=i(F),_t=n(F,"TD",{});var Za=l(_t);be=r(Za,"[-128, 127]"),Za.forEach(e),F.forEach(e),we=i(_),g=n(_,"TR",{});var G=l(g);vt=n(G,"TD",{});var tr=l(vt);Re=r(tr,"Int16Array"),tr.forEach(e),Ie=i(G),Y=n(G,"TD",{});var Mt=l(Y);Pe=r(Mt,"2"),mt=n(Mt,"SUP",{});var er=l(mt);Ce=r(er,"16"),er.forEach(e),ke=r(Mt,"= 65,536"),Mt.forEach(e),Se=i(G),pt=n(G,"TD",{});var ar=l(pt);xe=r(ar,"[-32768, 32767]"),ar.forEach(e),G.forEach(e),Ye=i(_),D=n(_,"TR",{});var K=l(D);Et=n(K,"TD",{});var rr=l(Et);$e=r(rr,"Int32Array"),rr.forEach(e),qe=i(K),$=n(K,"TD",{});var Lt=l($);Oe=r(Lt,"2"),yt=n(Lt,"SUP",{});var or=l(yt);Be=r(or,"32"),or.forEach(e),Ve=r(Lt,"= 4,294,967,296"),Lt.forEach(e),je=i(K),Tt=n(K,"TD",{});var nr=l(Tt);He=r(nr,"[-2147483648, 2147483647]"),nr.forEach(e),K.forEach(e),ze=i(_),A=n(_,"TR",{});var Q=l(A);gt=n(Q,"TD",{});var lr=l(gt);Je=r(lr,"Uint8Array"),lr.forEach(e),Ne=i(Q),q=n(Q,"TD",{});var Ft=l(q);Me=r(Ft,"2"),Dt=n(Ft,"SUP",{});var dr=l(Dt);Le=r(dr,"8"),dr.forEach(e),Fe=r(Ft,"= 256"),Ft.forEach(e),Ge=i(Q),At=n(Q,"TD",{});var sr=l(At);Ke=r(sr,"[0, 255]"),sr.forEach(e),Q.forEach(e),Qe=i(_),U=n(_,"TR",{});var W=l(U);Ut=n(W,"TD",{});var ir=l(Ut);We=r(ir,"Uint16Array"),ir.forEach(e),Xe=i(W),O=n(W,"TD",{});var Gt=l(O);Ze=r(Gt,"2"),bt=n(Gt,"SUP",{});var cr=l(bt);ta=r(cr,"16"),cr.forEach(e),ea=r(Gt,"= 65,536"),Gt.forEach(e),aa=i(W),wt=n(W,"TD",{});var hr=l(wt);ra=r(hr,"[0, 65535]"),hr.forEach(e),W.forEach(e),oa=i(_),b=n(_,"TR",{});var X=l(b);Rt=n(X,"TD",{});var ur=l(Rt);na=r(ur,"Uint32Array"),ur.forEach(e),la=i(X),B=n(X,"TD",{});var Kt=l(B);da=r(Kt,"2"),It=n(Kt,"SUP",{});var fr=l(It);sa=r(fr,"32"),fr.forEach(e),ia=r(Kt,"= 4,294,967,296"),Kt.forEach(e),ca=i(X),Pt=n(X,"TD",{});var _r=l(Pt);ha=r(_r,"[0, 4294967295]"),_r.forEach(e),X.forEach(e),ua=i(_),w=n(_,"TR",{});var Z=l(w);Ct=n(Z,"TD",{});var vr=l(Ct);fa=r(vr,"Uint8ClampedArray"),vr.forEach(e),_a=i(Z),V=n(Z,"TD",{});var Qt=l(V);va=r(Qt,"2"),kt=n(Qt,"SUP",{});var mr=l(kt);ma=r(mr,"8"),mr.forEach(e),pa=r(Qt,"= 256"),Qt.forEach(e),Ea=i(Z),St=n(Z,"TD",{});var pr=l(St);ya=r(pr,"[0, 255]"),pr.forEach(e),Z.forEach(e),Ta=i(_),R=n(_,"TR",{});var tt=l(R);xt=n(tt,"TD",{});var Er=l(xt);ga=r(Er,"BigInt64Array"),Er.forEach(e),Da=i(tt),j=n(tt,"TD",{});var Wt=l(j);Aa=r(Wt,"2"),Yt=n(Wt,"SUP",{});var yr=l(Yt);Ua=r(yr,"64"),yr.forEach(e),ba=r(Wt," = 18,446,744,073,709,551,615"),Wt.forEach(e),wa=i(tt),$t=n(tt,"TD",{});var Tr=l($t);Ra=r(Tr,"[-9223372036854775808, 9223372036854775807]"),Tr.forEach(e),tt.forEach(e),Ia=i(_),I=n(_,"TR",{});var et=l(I);qt=n(et,"TD",{});var gr=l(qt);Pa=r(gr,"BitUint64Array"),gr.forEach(e),Ca=i(et),H=n(et,"TD",{});var Xt=l(H);ka=r(Xt,"2"),Ot=n(Xt,"SUP",{});var Dr=l(Ot);Sa=r(Dr,"64"),Dr.forEach(e),xa=r(Xt," = 18,446,744,073,709,551,615"),Xt.forEach(e),Ya=i(et),Bt=n(et,"TD",{});var Ar=l(Bt);$a=r(Ar,"[0, 18446744073709551615]"),Ar.forEach(e),et.forEach(e),_.forEach(e),Jt.forEach(e),Ht=i(c),N=n(c,"P",{});var Ur=l(N);qa=r(Ur,"The only difference between Uint8Array and Uint8ClampedArray is that the if you try assign a number outside of the range [0, 255], the clamped array will round you up to 0 or down to 255. The Uint8Array will take loop over, so 256 becomes 0, and -1 becomes 255, etc. I don\u2019t think this has an effect on the random output code above though."),Ur.forEach(e),zt=i(c),M=n(c,"P",{});var br=l(M);Oa=r(br,"The \u201CU\u201D in the name stands for \u201Cunsigned\u201D, meaning the numbers are non-negative. The signed versions have are just centered around zero, so there are an equal amount of negative and non-negative outcomes."),br.forEach(e),this.h()},h(){Ir(v,"href","https://calendar.ihtfy.com/"),Ir(v,"rel","nofollow")},m(c,h){P(c,d,h),t(d,E),t(d,v),t(v,S),t(d,f),t(d,m),t(m,J),t(d,Zt),t(d,at),t(at,te),t(d,ee),t(d,rt),t(rt,ae),t(d,re),t(d,ot),t(ot,oe),t(d,ne),P(c,Vt,h),P(c,p,h),t(p,le),t(p,nt),t(nt,de),t(p,se),t(p,lt),t(lt,ie),t(p,ce),t(p,dt),t(dt,he),t(p,ue),P(c,jt,h),P(c,C,h),t(C,st),t(st,y),t(y,it),t(it,fe),t(y,_e),t(y,ct),t(ct,ve),t(y,me),t(y,ht),t(ht,pe),t(C,Ee),t(C,u),t(u,T),t(T,ut),t(ut,ye),t(T,Te),t(T,x),t(x,ge),t(x,ft),t(ft,De),t(x,Ae),t(T,Ue),t(T,_t),t(_t,be),t(u,we),t(u,g),t(g,vt),t(vt,Re),t(g,Ie),t(g,Y),t(Y,Pe),t(Y,mt),t(mt,Ce),t(Y,ke),t(g,Se),t(g,pt),t(pt,xe),t(u,Ye),t(u,D),t(D,Et),t(Et,$e),t(D,qe),t(D,$),t($,Oe),t($,yt),t(yt,Be),t($,Ve),t(D,je),t(D,Tt),t(Tt,He),t(u,ze),t(u,A),t(A,gt),t(gt,Je),t(A,Ne),t(A,q),t(q,Me),t(q,Dt),t(Dt,Le),t(q,Fe),t(A,Ge),t(A,At),t(At,Ke),t(u,Qe),t(u,U),t(U,Ut),t(Ut,We),t(U,Xe),t(U,O),t(O,Ze),t(O,bt),t(bt,ta),t(O,ea),t(U,aa),t(U,wt),t(wt,ra),t(u,oa),t(u,b),t(b,Rt),t(Rt,na),t(b,la),t(b,B),t(B,da),t(B,It),t(It,sa),t(B,ia),t(b,ca),t(b,Pt),t(Pt,ha),t(u,ua),t(u,w),t(w,Ct),t(Ct,fa),t(w,_a),t(w,V),t(V,va),t(V,kt),t(kt,ma),t(V,pa),t(w,Ea),t(w,St),t(St,ya),t(u,Ta),t(u,R),t(R,xt),t(xt,ga),t(R,Da),t(R,j),t(j,Aa),t(j,Yt),t(Yt,Ua),t(j,ba),t(R,wa),t(R,$t),t($t,Ra),t(u,Ia),t(u,I),t(I,qt),t(qt,Pa),t(I,Ca),t(I,H),t(H,ka),t(H,Ot),t(Ot,Sa),t(H,xa),t(I,Ya),t(I,Bt),t(Bt,$a),P(c,Ht,h),P(c,N,h),t(N,qa),P(c,zt,h),P(c,M,h),t(M,Oa)},d(c){c&&e(d),c&&e(Vt),c&&e(p),c&&e(jt),c&&e(C),c&&e(Ht),c&&e(N),c&&e(zt),c&&e(M)}}}function zr(z){let d,E;const v=[z[0],Pr];let S={$$slots:{default:[Hr]},$$scope:{ctx:z}};for(let f=0;f<v.length;f+=1)S=Ba(S,v[f]);return d=new jr({props:S}),{c(){xr(d.$$.fragment)},l(f){Yr(d.$$.fragment,f)},m(f,m){$r(d,f,m),E=!0},p(f,[m]){const J=m&1?qr(v,[m&1&&wr(f[0]),m&0&&wr(Pr)]):{};m&2&&(J.$$scope={dirty:m,ctx:f}),d.$set(J)},i(f){E||(Or(d.$$.fragment,f),E=!0)},o(f){Br(d.$$.fragment,f),E=!1},d(f){Vr(d,f)}}}const Pr={draft:!1,title:"pseudorandom",date:"2022-02-13",desc:"Playing around with crypto - No, not currency",tags:["code","math"]};function Jr(z,d,E){return z.$$set=v=>{E(0,d=Ba(Ba({},d),Rr(v)))},d=Rr(d),[d]}class Kr extends Cr{constructor(d){super();kr(this,d,Jr,zr,Sr,{})}}export{Kr as default,Pr as metadata};
