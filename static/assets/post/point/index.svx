---
draft: false
title: "point"
date: "2016-01-07"
coverImage: "points2000x1500.png"
desc: TODO
tags:
  - TODO
---

I made this in June of 2014. I was using processing (a java library) to make mosaic and pointillism style images from existing pictures.

_You can click the images below to see larger versions._

### Cloud

Generated circles are semi-uniformly distributed (small deviations from initial lattice)

\[gallery ids="95,89" type="rectangular"\]

### Lake

Using randomly placed circles of roughly equal diameter

\[gallery ids="96,90" type="rectangular"\]

Video showing shrinking polygons to reduce uncovered spots. I just realized this is the same concept of simulated annealing.

\[youtube https://www.youtube.com/watch?v=st9v2upmL70\]

### Fruit

Randomly placed quadrilaterals

\[gallery ids="84,86" type="rectangular"\]

### Jaguar

Using small polygons and larger polygons

\[gallery ids="97,91,92" type="rectangular"\]

### Another Jaguar

Random circles

\[gallery ids="94,88" type="rectangular"\]

### White and Pink

\[gallery ids="85,87" type="rectangular"\] \[youtube https://www.youtube.com/watch?v=BCXYKs8LsZQ\]

### Source:

\[code language="python"\] PImage bg; String img; float min; float max; int shape; boolean draw; float t = 5; boolean recording = false; boolean progressive = false;

void setup() { size(1600,900); // source image resolution img = "lake.png"; // source image name bg = loadImage("./images/" + img); // source image directory imageMode(CENTER); background(0); min = 1; // minimum shape size max = 8; // maximum shape size shape = 0; // 0 circle, 1 quad draw = true; // use mouse to color in recording = false; // output movie frames progressive = false; // simulated annealing }

void draw() { if (progressive) { t += 20; max = 50000./t; println(50000./t); } for (int i=0; i<500; i++) { if (shape == 0) { if (draw) { // for hand drawing int x = mouseX; int y = mouseY; int dx = abs(x-pmouseX); int dy = abs(y-pmouseY); float speed = sqrt(dx\*dx+dy\*dy); noStroke(); color c = bg.get(x,y); fill(c,128); ellipse(x,y,sqrt(speed\*2),sqrt(speed\*2)); } else { int x = int(random(bg.width)); int y =int(random(bg.height)); x -= x%min; y -= y%min; int r = int(random(max-min)+min); noStroke(); color c = bg.get(x,y); fill(c,128); ellipse(x,y,r,r); } } if (shape == 1) { int x = int(random(bg.width)); int y =int(random(bg.height)); noStroke(); color c = bg.get(x,y); fill(c,128); quad(x-int(random(max-min)+min),y-int(random(max-min)+min),x+int(random(max-min)+min),y-int(random(max-min)+min),x+int(random(max-min)+min),y+int(random(max-min)+min),x-int(random(max-min)+min),y+int(random(max-min)+min)); } } if (recording) { saveFrame("./images/movie/frames####.png"); // output frame } }

void keyPressed() { if (key == 'r' || key == 'R') { recording = !recording; // flag to save frames for animation } if (key == 'p' || key == 'P') { saveFrame("./images/Capped-" + img); // output image } } \[/code\]
